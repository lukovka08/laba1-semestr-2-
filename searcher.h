#ifndef H
#define H
#include "items.h"

/* Классы поисковика
 *
 * Будем использовать их как альтернативу полиморфизму метода search()
 * Почему? В нашем случае при использовании перегрузки этого метода
 * возникают два одинаковых определения для поиска по массе и по цене:
 *
 * std::vector<Item> search(double left, double right);
 *
 * 
 * А выкрутимся мы из этой ситуации с помощью функтора!
 *
 * Итак, для этого нам понадобится:
 * - Создать базовый для всех "поисковиков" класс Searcher и определить в нем
 * виртуальный функтор;
 * - Создать потомков класса, каждому из них переопределить поведение функтора;
 * - Передавать объекты его самого или его наследников в качестве параметра
 * методу search().
 *
 * Таким образом, мы заменили полиморфизм параметрический (вариации метода
 * search()) на полиморфизм динамический (переопределение метода базового
 * класса, в нашем случае - функтора)
 *
 * Такой подход описывает поведенческий паттерн проектирования "Стратегия",
 * а сам класс или его потомок представляет из себя делегат
 * Несомненными плюсами данного подхода является гибкость расширения
 * поведения и отсутствие необходимости переделывать класс, перегружая методы
 * К минусам же можно отнести необходимость описания нового класса каждый раз,
 * что в свою очередь приводит к увеличению количества оных.
 *
 * Можно было прибегнуть к помощи вариативных шаблонов, тогда при описании
 * всего лишь одного класса с функтором мы имели бы возможность описывать
 * только саму функцию-предикат, которую выполняет функтор. Однако, все же мы
 * не настолько круты :)
 */

namespace searcher {
    /* Это - базовый класс. При передаче его объекта в метод поиска
     * он вернет "истину" для каждого товара. Таким образом, метод поиска
     * вернет весь свой склад с товаром
     */
    class Base {
    public:
        Base() {}
        virtual bool operator()(const Item&);
        virtual ~Base() {}
    };

    // Поисковик по цене
    class byPrice: public Base {
    public:
        byPrice(double left, double right);
        bool operator()(const Item&);
        ~byPrice() {}
    private:
        double m_left;
        double m_right;
    };

    // Поисковик по массе
    class byWeight: public Base {
    public:
        byWeight(double left, double right);
        bool operator()(const Item&);
        ~byWeight() {}
    private:
        double m_left;
        double m_right;
    };

    // Поисковик по типу
    class byType: public Base {
    public:
        byType(unsigned type);
        bool operator()(const Item&);
        ~byType() {}
    private:
        unsigned m_type;
    };
}

#endif // H
